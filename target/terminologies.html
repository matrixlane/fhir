<!DOCTYPE HTML>



[%settitle 使用代码和术语%]
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
[%file newheader%]
</head>
<body>
[%file newnavbar%]



<%txheader%>

<h1>在资源中使用代码</h1>
<table class="colsn"><tr><td id="wg"><a _target="blank" href="[%wg vocab%]">[%wgt vocab%]</a> 工作组</td><td id="fmm"><a href="versions.html#maturity">成熟级别</a>：规范</td><td id="ballot"><a href="versions.html#std-process">标准状态</a>：<!--!ns!--><a href="versions.html#std-process">规范</a></td></tr></table>
[%normative page infrastructure%]
<a name="bindings"></a>
<p>
FHIR资源中的许多元素具有<b>编码值</b>：一些固定的字符串（字符序列），在其他地方分配，用于标识某个定义的“概念”。字符序列及其含义可以在以下几个地方定义：
</p>
<ul>
 <li>作为本规范中定义的一组固定值之一</li>
 <li>在互联网RFC中（例如，mime类型、语言）</li>
 <li>HL7规范（<a href="https://www.hl7.org/implement/standards/product_brief.cfm?product_id=186">HL7 v3</a>代码系统或<a href="http://www.hl7.org/implement/standards/product_brief.cfm?product_id=185">HL7 V2</a>表）</li>
 <li>一些外部术语或本体，例如<a href="http://loinc.org">LOINC</a>或<a href="http://www.snomed.org">SNOMED CT</a></li>
 <li>应用程序中的本地维护的字典、查找表或枚举（有关本地定义值集的进一步讨论，请参见<a href="profiling.html">“对FHIR进行配置”</a>）</li>
</ul>
<p>
这些定义代码的方法统称为“代码系统”。
这个列表远非完整；有许多定义代码系统的方法，它们在复杂性和规模上各不相同。
</p>
<p>
在本规范中，编码值始终被视为由“系统”和“代码”组成的一对，其中系统是一个URL，用于标识定义代码的代码系统。请注意，<code>system</code>值始终区分大小写。不同的代码系统根据其定义的代码是否区分大小写而制定自己的规则。请注意，FHIR本身定义的所有代码都区分大小写，并且应使用提供的大小写（通常是小写）。
</p>
<p>
FHIR使用编码值的框架基于<a href="http://www.hl7.org/documentcenter/public/standards/V3/core_principles/infrastructure/coreprinciples/v3modelcoreprinciples.html">HL7 v3核心原则</a>文档中第5节定义的基本框架，包括代码系统和值集之间的分离。
</p>

<p>
表示编码值的一般模式是使用以下四个元素：
</p>
<table class="grid">
 <tr> <td>system</td> <td>标识系统的URI（参见下文）</td> </tr>
 <tr> <td>version</td> <td>表示原始代码系统的版本的字符串值（参见<a href="codesystem.html#versioning">代码系统版本控制</a>）</td> </tr>
 <tr> <td>code</td> <td>作为代码系统定义的概念的字符串值</td> </tr>
 <tr> <td>display</td> <td>代码系统定义的概念的描述</td> </tr>
</table>
<div class="example">
<p>
<a href="datatypes.html#Coding">Coding</a>数据类型表示了这种模式。以下示例显示了一个使用LOINC系统、用于定义的LOINC版本和由LOINC分配的显示的LOINC代码：
</p> 
<pre class="json">  
{ 
  "system" : "http://loinc.org",
  "version" : "2.62",
  "code" : "55423-8",
  "display" : "Number of steps in unspecified time Pedometer"
}
</pre>
</div>
<a name="type-list"> </a>
<table class="grid">
 <tr><td colspan="2">在资源中携带代码时，使用了几种不同的数据类型：</td></tr>
 <tr><td><a href="datatypes.html#code">code</a><a name="code"></a></td><td>实例仅表示<i>code</i>。系统是隐含的 - 它作为元素定义的一部分进行定义，不在实例中携带。</td></tr>
 <tr><td><a href="datatypes.html#Coding">Coding</a><a name="Coding"></a></td><td>具有<i>code</i>和<i>system</i>元素的数据类型，用于标识代码定义的来源</td></tr>
 <tr><td><a href="datatypes.html#CodeableConcept">CodeableConcept</a><a name="CodeableConcept"></a></td><td>通过纯文本和/或一个或多个<code>coding</code>元素表示概念的类型（有关代码翻译和在CodeableConcept中使用文本的讨论，请参见<a href="datatypes.html#CodeableConcept">数据类型注释</a>）</td></tr>
 <tr><td><a href="references.html#CodeableReference">CodeableReference</a><a name="CodeableReference"></a></td><td>一个类型，可以引用另一个资源，或者使用<a href="datatypes.html#CodeableConcept">CodeableConcept</a>引用一个概念</td></tr>
 <tr><td colspan="2">此外，以下数据类型还携带了编码值或可视为代码并绑定到值集的内容：</td></tr>
 <tr><td><a href="datatypes.html#Quantity">Quantity</a><a name="Quantity"></a></td><td>实例具有用于携带单位类型的<i>system</i>和<i>code</i>元素，这些元素可以绑定到值集</td></tr>
 <tr><td><a href="datatypes.html#string">string</a><a name="string"></a></td><td>实例携带一个字符串。在某些情况下，应用程序可能希望控制特定元素的有效字符串集，因此可以将字符串值视为代码元素（如<code>code</code>）</td></tr>
 <tr><td><a href="datatypes.html#uri">uri</a><a name="uri"></a></td><td>与<code>string</code>类似，URI可以视为代码元素</td></tr>
</table>
<p>
注：
</p>
<ul>
 <li>通常，数据类型的选择由资源本身决定。在选择扩展的数据类型时，请参阅FHIR Confluence页面上关于<a href="https://confluence.hl7.org/display/FHIR/Guide+to+Designing+Resources#Choice+of+coding+data+type">数据类型选择的建议</a>。</li>
 <li>有关将类型<a href="datatypes.html#string">string</a>和<a href="datatypes.html#uri">uri</a>绑定到值集的更多信息，请参见下文。</li>
</ul>

<a name="bindings"></a>
<a name="valuesets"></a>
<h2>编码值、编码系统和值集</h2>
<p>
在元素中允许的编码值集合被称为"值集"。在使用这些数据类型的任何地方，规范会将一个值集与元素进行"绑定"，对于code、Coding和CodeableConcept类型，总是如此。
</p>
<ul>
 <li><b><a href="codesystem.html">编码系统</a></b>通过正式定义给概念赋予意义，并分配代表这些概念的编码</li>
 <li><b><a href="valueset.html">值集</a></b>指定了一组由编码系统定义的代码，可以在特定上下文中使用</li>
 <li><b><a href="#binding">绑定</a></b>将一个值集应用到一个元素，并指定值集的使用规则</li>
</ul>
<p>
编码系统和值集之间的区别是一个重要的区分，但很容易被实施者忽视，因为在系统设计中经常被忽略。例如，经常会看到一个应用程序表，其中包含一些LOINC代码和一些其他内部代码的混合列表。通常情况下，它们之间没有明确的区分；只有一个代码看起来像LOINC代码，才能暴露其来源。
</p>
<p>
概念的编码系统标识符对于可互操作的数据交换是必要的。每个编码系统都被分配一个URI。编码系统标识符（URI）和概念标识符（例如代码）的组合是唯一的。请注意，当编码系统不遵循概念永久性规则时，可能需要编码系统版本来实现唯一性。
</p>
<p>
在前面段落的混合列表示例中，有两个编码系统：<a href="https://terminology.hl7.org/LOINC.html">LOINC</a> (http://loinc.org) 和一个本地的编码系统，其URI为：http://example.com/codesystems/additional-test-codes。
值集定义包括来自这两个编码系统的概念标识符（代码）。ValueSet.url（例如"http://example.com/fhir/ValueSet/test-codes"）是值集的规范标识符。
值集的URI与编码系统的URI不同。概念总是通过<code>code</code>和<code>system</code>进行标识，除了简单的数据类型<code>code</code>，其中编码系统在规范（例如核心规范、实施指南、配置文件）中是固定的，并且没有明确表示。
</p>
<p>
请注意，对于某些编码系统，有一种单一的正确机制来表示由该系统定义的代码，即单个URL。这些单个URL在RDF格式的上下文中用于启用本体推理。URL通常是对可以提供有关概念的附加定义材料的Web源的直接引用。如果已知机制，并由编码系统定义，它将在本规范中进行描述。
</p>

<a name="system"></a>
<h2>选择一个系统</h2>

<p>
<code>system</code>中的URL始终是对代码系统的引用，而不是值集。 <code>system</code>确保可以将代码明确地追溯回其原始定义，并且可以通过不同系统一致地执行逻辑比较、匹配和推理。因此，选择正确的系统属性URI至关重要。
</p>
<p>
对于给定的代码系统，在确定<i>system</i>中使用的正确值时，可以按照以下顺序进行操作：
</p>
<ul>
 <li><a href="https://terminology.hl7.org/">Terminology.hl7.org </a>（THO）- 如果代码系统在此处列出，则应使用规范的CodeSystem URL。</li>
 <li>未在<a href="https://terminology.hl7.org/">Terminology.hl7.org </a>中列出，并且代码系统是HL7外部的，则应使用HTA授权的CodeSystem标识符。
  <ul>
   <li>检查HL7 Terminology Authority（HTA）JIRA项目，以确定是否正在进行获取标识符的请求
    <ul>
	 <li><a href="https://jira.hl7.org/projects/HTA/issues/">https://jira.hl7.org/projects/HTA/issues/</a></li>
	 <li>没有进行中的JIRA？检查<a href="https://confluence.hl7.org/pages/viewpage.action?pageId=91999004">HTA Confluence页面</a>，以确定是否正在进行获取标识符的请求。</li>
	</ul>
   </li>
   <li>如果HTA资源都无法解决您的问题，
    <ul>
	 <li>启动<a href="https://confluence.hl7.org/display/TA/Request+Content+in+External+Terminologies">HTA流程以请求外部术语中的内容</a>，并传达您分配的临时标识符</li>
	 <li>按照以下模式创建临时标识符：
	  <ul>
	   <li>terminology.hl7.org/temporary/CodeSystem/xxxxx   （其中xxxx是有意义的文本字符串）</li>
	  </ul>
	 </li>
	</ul>
   </li>
   <li>在授权标识符可用时，监视HTA请求并更新您的规范</li>
  </ul>
 </li>
 <li>未在<a href="http://terminology.hl7.org/">Terminology.hl7.org</a>中列出，并且代码系统是HL7内部的，并且预计将在生产系统中使用
  <ul>
  <li>如果在THO中找不到您的CodeSystem，
    <ul>
	 <li>按照以下模式创建规范URL：terminology.hl7.org/CodeSystem/xxxxx    （其中xxxx是有意义的文本字符串）
	  <ul>
	   <li>这将启动在terminology.hl7.org中为您的CodeSystem创建NamingSystem资源的过程</li>
	   <li>CodeSystem内容可以保留在IG中</li>
	  </ul>
	 </li>
	</ul>
   </li>
   <li>当CodeSystem处于IG作者/开发人员/相关方确信足够的状态时，并且尽早进行，
    <ul>
	 <li><a href="https://confluence.hl7.org/display/VMAH/How+To+Submit+a+UTG+Change+Proposal">启动UTG流程</a>，将CodeSystem内容移至THO</li>
	</ul>
   </li>
   <li>将自己设置为UP JIRA工单的关注者，并在CodeSystem在THO中时更新您的规范</li>
  </ul>
 </li>
 <li>未在<a href="http://terminology.hl7.org/">Terminology.hl7.org</a>中列出，并且代码系统旨在<i>永不在生产系统中使用</i>，并且将用于创建与示例绑定强度绑定的值集
  <ul>
  <li>如果示例概念代码将在多个IG中使用，
   <ul>
    <li>使用以下URL模式：[ig-base-canonical]/CodeSystem/example-xxxxx（来自多个IG中的一个，没有理由在多个IG中定义相同的示例CodeSystem）</li>
   </ul>
  </li>
  <li>如果示例概念代码仅在单个IG中使用：
   <ul>
    <li>按照以下模式创建标识符：[ig-base-canonical]/CodeSystem/example-xxxxx（其中xxxxx是传达意图的特定字符串）</li>
   </ul>
  </li>
  </ul>
 </li>
</ul>
<p>

在罕见的情况下，如果此列表无法解析代码系统，请按照以下模式创建临时标识符：terminology.hl7.org/temporary/CodeSystem/xxxx。请联系HL7词汇共同主席。
</p>
<p>
对于代码系统的发布者，在定义要使用的正确URI时应考虑以下几点：
</p>
<ul>
 <li>一旦定义并投入使用，在罕见情况下，代码系统的URI可能会发生变化。实施者应设计其系统以支持代码系统标识符的更改。Terminology.hl7.org实现了NamingSystem资源来管理代码系统标识符及其有效日期范围。</li>
 <li>一个http:地址应该解析为代码系统的某些有用描述。理想情况下，如果用户使用FHIR媒体类型设置地址发出请求，服务器将以CodeSystem资源的形式响应，但也允许其他人类或可计算的定义。</li>
 <li>HTTP地址应该是永久链接，可以重定向到当前正确的内容。</li>
 <li>代码系统URI的范围以及其命名空间中代码和显示的正确使用将由HTA明确定义。请参阅<a href="https://terminology.hl7.org/SNOMEDCT.html">SNOMED CT</a>，<a href="https://terminology.hl7.org/RxNorm.html">RxNorm</a>，<a href="https://terminology.hl7.org/LOINC.html">LOINC</a>和<a href="https://terminology.hl7.org/NDC.html">NDC</a>的示例。</li>
 <li>所有HL7内部使用的代码系统都使用<a href="http://terminology.hl7.org/">Terminology.hl7.org</a>作为基础。通常，URL的分配是分层的，并且在选择基本URL时需要非常小心。
  <ul>
   <li>URL模式为：terminology.hl7.org/CodeSystem/xxxxxx/xxxxxxx</li>
  </ul>
 </li>
</ul>
<p>
注意：如果代码系统在<a href="valueset.html">ValueSet</a>资源中以包的形式提供，则<code>system</code>值的正确URL是<i>ValueSet.codeSystem.system</i>，而不是<i>ValueSet.uri</i>。
</p>

<a name="grammar"></a>
<h2>复杂的代码系统</h2>
<p>
所有的代码系统都定义了一组概念，为它们分配特定的代码，并提供定义材料来指导实施者正确使用和理解这些代码。许多代码系统定义了不同概念之间的关系 - 是一个、部分、分类等等。这些特性在<a href="codesystem.html">CodeSystem</a>资源中表示，并使用上述其中一种代码数据类型进行交换。
</p>
<p>
一些代码系统定义了如何使用代码系统定义的基本概念构建复杂表达式的规则。这有时被称为“后协调”。一些定义了表达式语法的著名代码系统包括：
</p>
<ul>
 <li><a href="http://www.snomed.org">SNOMED CT</a></li>
 <li><a href="http://ucum.org/ucum.html">UCUM</a></li>
 <li><a href="http://tools.ietf.org/html/bcp13">Mime Types</a></li>
 <li><a href="http://tools.ietf.org/html/bcp47">Language</a></li>
 <li><a href="http://www.who.int/standards/classifications/classification-of-diseases">ICD-[X]</a></li>
</ul>
<p>
还有许多其他的代码系统。代码系统定义的任何表达式仍然被视为“代码”并表示为这样。
</p>
<div class="example">
<p>
这个例子展示了一个SNOMED CT表达式：
</p> 
<pre class="json">  
{ 
  "system" : "http://snomed.info/sct",
  "code" : "128045006:{363698007=56459004}"
}
</pre>
<p>
这个例子中没有提供显示。请参阅这里的讨论：<a href="https://confluence.ihtsdotools.org/x/UwbJAQ">https://confluence.ihtsdotools.org/x/UwbJAQ</a>
</p>
</div>

<a name="binding"></a>
<h2>控制编码值的使用</h2>

<p>
当一个元素与一个值集绑定时，它具有以下属性的绑定：
</p>
<table class="grid">
 <tr><td>Name</td><td>在展示绑定相关信息时使用的描述性名称</td></tr>
 <tr><td>Strength</td><td>绑定应该如何理解-见下文</td></tr>
 <tr><td>Reference</td><td>定义值集的URL。通常，这是对<a href="valueset.html">ValueSet</a>资源的直接引用，但也可以是更间接的引用，其中值集是推断出来的</td></tr>
 <tr><td>Description</td><td>代码使用的文本描述。如果没有引用，必须填写此项。当有引用时，可以用它来添加关于值集的使用和实现的附加说明</td></tr>
</table>
<p>
绑定总是使用<a href="elementdefinition-definitions.html#ElementDefinition.binding">ElementDefinition.binding</a>来表示。
</p>

<div class="trial-content">
<p style="background-color: #ffcccc; border:1px solid grey; padding: 5px; max-width: 790px;">
  附加绑定和元素<code>ElementDefinition.binding.additional</code>在FHIR Release 5中被视为<a href="versions.html#std-process" title="标准状态=试用">试用</a>。
</p>
    
<p>
此外，元素可能具有附加的绑定。这些附加绑定不会替代主要绑定，而是提供有关元素中代码使用的附加信息。附加绑定具有以下属性：
</p>
<table class="grid">
  <tr><td><b>purpose</b></td><td>
    此附加绑定的用途：
    <ul>
      <li><b>required</b> | <b>extensible</b> | <b>preferred</b>：这些绑定与主要绑定的含义相同，但通常伴随着一些附加的使用细节，
       限制了它们在特定上下文中的应用，其中比一般情况下更紧密的绑定可能是可能的</li>
      <li><b>component</b>：值集是主要一致性绑定的组成部分。这用于提供有关主要值集的使用或其部分的附加文档。例如，主要值集可以允许使用SNOMED CT和LOINC，
          但作者希望提供有关它们如何（不同地）使用的附加特定文档</li>
      <li><b>maximum</b>：如果主要一致性绑定的强度为extensible，则用于扩展该值集的任何代码都必须来自指定的值集。
          请注意，此附加绑定替换了在FHIR Release 5中不再定义的扩展<code>http://hl7.org/fhir/StructureDefinition/elementdefinition-maxValueSet</code>
          <i>(todo: 实际删除它，并替换现有的使用)</i></li>
      <li><b>minimum</b>：定义所有符合性应用程序必须接受的有效值的最小代码集。这是实施应用程序的<a href="obligations.html">义务</a>，通常与附加义务相关联，
          表达应用程序应该如何处理代码的内容。请注意，此附加绑定替换了在FHIR Release 5中不再定义的扩展<code>http://hl7.org/fhir/StructureDefinition/elementdefinition-minValueSet</code>
          <i>(todo: 实际删除它，并替换现有的使用)</i></li>
      <li><b>candidate</b>：在某些情况下，候选值集可以替代整体一致性值集；通常在文档中或<code>usage</code>元素中定义</li>
      <li><b>current</b>：新记录必须使用的值集。这将是主要一致性值集，但存在不符合此要求的旧记录，而且永远不会符合。同样，这是应用程序的义务，
          而不是可以在资源实例本身中测试的内容</li>
      <li><b>ui</b>：提供此值集以帮助用户在给定上下文中进行查找</li>
      <li><b>starter</b>：此值集是设计系统时的良好代码集。这些通常是重要或常用的代码。当一致性值集非常大或由于语法而无限时，提供起始集可以帮助它们启动</li>
    </ul>
  </td></tr>
  <tr><td><b>valueSet</b></td><td>
    引用附加绑定的值集的规范URL
  </td></tr>
  <tr><td><b>documentation</b></td><td>
    描述在给定目的和用法下在此元素中使用此值集的Markdown
  </td></tr>
  <tr><td><b>shortDoco</b></td><td>
    一个简短的纯文本字符串，通常只是一个句子，用于在配置文件的表格形式中概括文档
  </td></tr>
  <tr><td><b>usage</b></td><td>
    一组限制附加绑定使用范围的限定符。通常，绑定受到司法/领域的限制，但也可以限制为特定的临床或工作流上下文。
    本规范不详细说明实现如何确定何时应用使用条件，因此在指定使用情况时，应在实施指南中解决此问题
  </td></tr>
  <tr><td><b>any</b></td><td>
    如果一个元素重复出现，则主要绑定同样适用于所有重复项。默认情况下，附加绑定也是如此，但将<code>any = true</code>设置为意味着
    附加绑定可以满足任何一个重复项。这允许为不同的重复项设置多个绑定，而无需切片的开销。将any设置为true只对具有<code>purpose = conformance</code>的附加绑定真正有意义
  </td></tr>
</table>
</div>
	
<a name="references"></a>

<h3>值集引用</h3>
<p>
在规范中有许多地方引用值集，以将编码值绑定到值集中：
</p>
<table class="grid">
 <tr><td><a href="elementdefinition.html">ElementDefinition</a>.binding.valueSet</td><td>用于将定义的元素绑定到值集，还有<code>ElementDefinition.binding.additional.valueSet</code></td></tr>
 <tr><td><a href="conceptmap.html">ConceptMap</a>.source[x]和.target[x]</td><td>用于指示概念映射的范围-从一个值集到另一个值集</td></tr>
 <tr><td><a href="questionnaire.html">Questionnaire</a>.item.answerValueSet</td><td>指示一组问题的答案来自值集</td></tr>
 <tr><td><a href="valueset.html">ValueSet</a>.compose.include.valueSet</td><td>值集的内容还包括导入的值集的内容</td></tr>
 <tr><td><a href="operationdefinition.html">OperationDefinition</a>.parameter.binding.valueSet</td><td>用于将定义的参数绑定到值集</td></tr>
 <tr><td><a href="[%extensions-location%]StructureDefinition-valueset-reference.html">ValueSet Reference Extension</a></td><td>指示从指定的值集中选择了一个编码值</td></tr>
</table>
<p>
在引用值集时，通常引用的是值集的<a href="valueset.html#compositions">定义</a> - 即定义了值集中的哪些代码的值集。
需要一个<a href="terminology-service.html">术语服务器</a>将此定义转换为在操作上下文中<a href="valueset.html#expansion">实际扩展中指定的值集中的代码</a>。
</p>

<p>
在这个列表中，有两种类型的值集引用，直接引用和逻辑引用。
</p>

<a name="direct"></a>
<h4>直接值集引用</h4>
<p>
直接值集引用的类型为<a href="references.html#Reference">Reference</a>，它直接引用基于URL的值集，通常是指运行<a href="http.html">FHIR RESTful API</a>的术语服务器。当访问基于这种引用的值集时，系统应该直接访问URL（根据本地上下文将相对引用转换为绝对引用）。如果此过程失败，系统将无法解析该值集，并必须适当处理错误。
</p>
<p>
示例：
</p>
<pre>
GET fhir/Questionnaire/234

&lt;Questionnaire&gt;
  ...
  &lt;question&gt;
    &lt;options&gt;
      &lt;reference value=&quot;ValueSet/234234&quot;/&gt;
    &lt;/options&gt;
  &lt;/question&gt;
  ....
&lt;/Questionnaire&gt;
</pre>
<p>
这指定了问卷的值来自于同一FHIR端点上具有id 234234的ValueSet。为了解析这个引用，系统会GET fhir/ValueSet/234234。
</p>
<p>
通常情况下，像这样的直接引用对于内部引用、封闭的或者精心管理的生态系统是很好的。但在更一般的情况下，这些引用随着时间的推移往往变得脆弱，因为Web URL（包括RESTful API URL）很容易被重新分配。因此，鼓励系统使用逻辑值集引用。
</p>

<a name="logical"></a>
<h4>逻辑值集引用</h4>
<p>
逻辑值集引用具有类型<a href="datatypes.html#uri">uri</a>，其中提供了一个绝对URI，与ValueSet.url中的URI匹配。值集URL可以是一个解析为固定Web地址的Web地址，作为该值集的权威来源。或者，系统可以查询其术语服务器以解析具有该URL作为其标识的值集。
</p>
<p>
示例：
</p>
<pre>
&lt;StructureDefinition&gt;
  ...
  &lt;element&gt;
    ...
    &lt;binding&gt;
      ...
      &lt;valueSet value=&quot;http://hl7.org/fhir/ValueSet/clinical-findings&quot;/&gt;
    &lt;/binding&gt;
    ...
  &lt;/element&gt;
  ....
&lt;/StructureDefinition&gt;
</pre>
<p>
这指定该元素绑定到具有ValueSet.url为<a href="http://hl7.org/fhir/ValueSet/clinical-findings">http://hl7.org/fhir/ValueSet/clinical-findings</a>的值集。访问该值集的一种方法是尝试GET http://hl7.org/fhir/ValueSet/clinical-findings - 对于该值集有效 - http://hl7.org/fhir/ValueSet/clinical-findings返回该URL的权威值集。
</p>
<p>
或者，可以使用本地术语服务器解析值集。如果运行一个<a href="terminology-service.html">FHIR术语服务器</a>，则可以这样工作：
</p>
<pre>
GET fhir/ValueSet?url=http://hl7.org/fhir/ValueSet/clinical-findings
</pre>
<p>
如果术语服务器知道该值集，则会返回该值集。如果URL未解析为权威值集，并且术语服务器不知道该值集，则系统无法解析该值集，并必须适当处理错误。
</p>
<p>
值集URL允许是诸如UUID（例如urn:uuid:c0e0d027-1250-4278-8f44-33a49dc67916）之类的URI。这些值集无法直接访问，必须来自术语服务器。请注意，HL7术语定义了许多具有不可解析的逻辑URL的值集（例如<a href="https://terminology.hl7.org/SNOMEDCT.html">SNOMED CT</a>，<a href="https://terminology.hl7.org/RxNorm.html">RxNorm</a>和<a href="https://terminology.hl7.org/LOINC.html">LOINC</a>的示例）。
</p>
<p>
使用直接引用权威值集的逻辑引用是最简单和最可靠的方法。但是，这需要适当的托管安排，并且不能始终保证，因此不是必需的。
</p>
<p><b>特定版本的逻辑引用</b></p>
<p>
值集具有两部分标识符：URL和版本。某些值集只有一个“版本”；值集内容的修订将导致分配新的URL。然而，其他值集保持相同的URL，并更改版本。术语服务器可以具有具有不同版本的相同ValueSet.url的多个值集。
</p>
<p>
为了准确指定值集引用中引用的值集的版本，在规范URL后附加版本，使用“|”分隔，如下所示：
</p>
<pre>
&lt;valueSet value=&quot;http://hl7.org/fhir/ValueSet/clinical-findings|0.8&quot;/&gt;
</pre>
<p>
这是对值集的特定版本引用。在术语服务器上搜索此内容将如下所示：
</p>
<pre>
GET fhir/ValueSet?url=http://hl7.org/fhir/ValueSet/clinical-findings&amp;version=0.8
</pre>
<p>
请注意，如果值集引用没有版本，并且服务器找到多个值集的版本，则使用值集的系统应选择最新版本的值集并使用该版本。请注意，这适用于所有<a href="references.html#canonical">一致性资源</a>。
</p>

<a name="unbound"></a>
<h4>未绑定</h4>
<p>
请注意，作为持续开发的一部分，一些具有编码数据类型的元素根本没有绑定到任何值集。这些元素需要提供绑定。
</p>

<a name="strength"></a>

<h3>绑定强度</h3>
<p>
几乎所有具有编码数据类型的元素都与一个值集进行绑定。这些绑定与值集的紧密程度有不同的灵活性：
</p>
<%linkcodelist http://hl7.org/fhir/binding-strength%>
<p>
对于应用于不同数据类型的“required”和“extensible”绑定强度，其精确的一致性标准因数据类型而异，如下面的段落所述。
</p>
<p>
无论绑定强度如何，当使用<a href="structuredefinition.html">StructureDefinition</a>来描述本地使用时，可以将元素绑定到不同的值集，以便更加精确地确定可以用于这些元素的编码值，和/或增加绑定的强度。对此有不同的规则，取决于绑定强度，如下所述。通常预计，各个司法管辖区、项目和供应商将共同选择实际的工作值集。
</p>

<a name="simple"></a>
<a name="code"></a>
<a name="required"></a>
<h4>必需的绑定强度</h4>
<p>
<i>为了符合规范，数据元素必须包含绑定值集扩展中的一个值。</i>
</p>
<p>
如果绑定强度是必需的，数据元素必须包含绑定值集中的一个值。
</p>
<p>
必需的绑定强度用于需要严格控制值的元素，以便可以自信地解释该元素。除非元素具有无上下文（即没有binding.additional.usage）的<a href="elementdefinition-definitions.html#ElementDefinition.binding.additional">附加绑定</a>，否则必须使用必需的绑定强度用于具有代码类型的元素。对于符合此规则的例外情况，需要获得FHIR-I工作组的批准，并记录符合条件的模式。
</p>
<p>
在基本的FHIR规范中，必需的绑定强度通常仅用于'code'数据类型。在配置文件中，当在使用上下文中达成一致意见，指定的一组代码是唯一可用的代码时，可以更广泛地使用它。
</p>
<p>
当必需的绑定与<a href="datatypes.html#CodeableConcept">CodeableConcept</a>数据类型一起使用时，应遵循以下规则：
</p>
<ul>
 <li>至少应存在一个Coding元素</li>
 <li>Coding值中的一个应来自指定的值集</li>
 <li>可以提供<code>text</code>，并且始终建议提供，但不能替代所需的代码</li>
</ul>
<p>
如果将必需的绑定应用于具有最大基数 &gt; 1的元素，则绑定适用于所有元素。
</p>
<p>
注意：当将绑定应用于<a href="references.html#CodeableReference">CodeableReference</a>时，这些规则也适用于其<code>concept</code>属性。
</p>
<p>
当在<a href="datatypes.html#Coding">Coding</a>之外的<a href="datatypes.html#code">code</a>数据类型中使用必需的绑定时，应遵循以下规则：
</p>
<ul>
 <li>值集扩展中的代码必须独立于代码系统。</li>
 <li>如果值集来自多个代码系统或HL7定义的代码系统，则值集必须指定每个代码系统的版本。
  <ul>
   <li>即，如果代码系统在发布具有绑定的规范之后发生演变，这些更改对规范的使用没有任何影响。</li>
   <li>在FHIR核心规范中定义值集时，允许使用的代码列表将在核心规范XML模式中固定。</li>
  </ul>
 </li>
 <li>元素绑定到定义了可用代码集的某个外部标准（典型示例包括<a href="http://www.rfc-editor.org/bcp/bcp13.txt">Mime Types</a>、
<a href="http://tools.ietf.org/html/bcp47">Language Codes</a>、<a href="http://unitsofmeasure.org">UCUM</a>等）</li>
 <li>只能在FHIR规范的后续版本中扩展可使用的代码列表</li>
 <li>代码之间的比较始终区分大小写，除非通过引用（例如ValueSet.compose）选择代码，并且引用的规范明确说明了其他情况。</li>
 <li>如果绑定值集在规范之外定义，则绑定必须指定值集版本。</li>
</ul>
<p>
当元素绑定到必需值集时，<a href="profiling.html">派生配置文件</a>可以规定可使用的代码的规则，包括从允许使用中删除代码，但不能为这些元素指定其他代码。
</p>
<p>
有关必需绑定的示例，请参见<a href="terminologies-binding-examples.html#required">术语绑定示例</a>。
</p>                                                                                                                                                
  

<a name="extensible"></a>
<h4>可扩展的绑定强度</h4>
<p>
<i>为了符合规范，数据元素应包含绑定值集扩展中的一个值，如果值集中的任何代码都可以应用于所传达的概念。</i>
</p>
<p>
当在规范或配置文件级别达成共识，应使用编码值，但无法创建已知覆盖所有用例（包括尚未出现的用例）的有界代码列表时，使用可扩展的绑定。
</p>
<p>
请注意，可扩展的是值集<b>绑定</b>，而不是值集本身。为了简洁和清晰起见，请将下文中所有对值集的引用视为对可扩展绑定值集的内容逻辑定义（CLD）的评估，除非明确指明引用值集定义。如果值集可以扩展，则适当的扩展等同于对CLD的评估。
</p>
<p>
如果值集中没有适用的概念（基于人工审核），则可以使用替代概念（系统/代码对、系统/版本/代码三元组或文本）。替代概念可以在<code>is-a</code>层次结构中具有任何特定级别（参见<a href="terminologies-binding-examples.html#extensible.c2">条件实例＃2</a>）。
</p>
<ol>
 <li>如果值集中存在与可扩展绑定值集的含义匹配的概念，则使用该概念。</li>
 <li>如果值集中不存在与可扩展绑定值集的含义匹配的概念，并且可扩展绑定值集中存在至少一个含义包括但更为一般的含义，该含义是要在资源实例中表示的元素的含义，则：</li>
  <ul>
   <li>在实例中使用的代码应来自值集中的一个适用概念，并且应是最接近更一般可用匹配的预期元素实例含义。如果数据类型是Coding，则只能发送值集中的适用概念。</li>
   <li>如果数据类型是CodeableConcept，则可以将更具体的代码（不在可扩展绑定值集中）作为附加的Coding包含在实例中，以更完整地表示预期含义，但不能代替值集扩展中的代码。这有助于确保系统知道应该接收和构建逻辑的哪些代码，并促进互操作性。</li>
  </ul>
 <li>仅当上述两种情况不适用时：</li>
  <ul>
   <li>可以使用值集之外的替代代码。</li>
   <li>可以发送CodeableConcept.text中的文本。</li>
  </ul>
</ol>
<p>
为了清晰起见，下表总结了每种可绑定数据类型的可扩展性规则：
</p>
<table class="grid">
<tr><td>CodeableConcept</td><td> 
<ol>
<li>存在来自值集的Coding，或</li>
<li>存在表示值集无法表达的概念的Coding，或</li>
<li>存在没有Coding的CodeableConcept.text，或</li>
<li>存在传达值集无法表达的替代概念的任何扩展</li>
</ol>
</td></tr>
<tr><td>Coding </td><td> 
<ol>
<li>存在来自值集的Coding，或</li>
<li>存在表示值集无法表达的概念的Coding，或</li>
<li>存在传达值集无法表达的替代概念的任何扩展</li>
</ol>
</td></tr>
<tr><td>Quantity </td><td> 
<ol>
<li>Quantity.code和Quantity.system来自值集，或</li>
<li>存在表示值集无法表达的概念的Quantity.code和Quantity.system，或</li>
<li>存在传达值集无法表达的替代单位概念的任何Quantity.extension</li>
</ol>
</td></tr>
<tr><td>uri, string </td><td> 
<ol>
  <li>存在来自值集的值，或</li>
  <li>存在表示值集无法表达的概念的值</li>
  <li>存在传达值集无法表达的替代概念的任何扩展（例如，如果需要传达除URI之外的数据类型）</li>
</ol>
</td></tr>
<tr><td>code </td><td> 
<ol>
<li>存在来自值集的值，或</li>
<li>存在传达值集无法表达的替代概念的任何扩展</li>
</ol>
</td></tr>
</table>

<p>
对于<a href="references.html#CodeableReference">CodeableReference</a>的<code>concept</code>属性，适用相同的规则。
</p>
<p>
如果将可扩展绑定应用于具有最大基数 &gt; 1 的元素，则该绑定适用于所有元素的重复项。
</p>
<p>
对于可扩展绑定的元素，<a href="profiling.html">派生配置文件</a>可以规定可使用的代码规则，但除非在父配置文件的可扩展绑定值集中找不到具有适当含义的代码，否则不能为这些元素选择新的或附加的代码。您只能约束，不能放宽。
</p>
<p>
请注意，如果正在使用valueset-reference扩展，并且元素实例中的代码来自于可扩展绑定值集之外，则扩展必须引用与所选择的代码不同的值集定义（或者如果没有其他值集引用可用，则不能在该实例中使用该扩展）。
</p>
<h5>可扩展绑定的示例</h5>
<p>
请参阅<a href="terminologies-binding-examples.html#extensible">示例</a>以帮助解释可扩展绑定这个困难但重要的主题。
</p>

<a name="preferred"></a>
<h4>首选绑定强度</h4>
<p>
<i>为了实现互操作性，鼓励实例使用指定的代码，但不使用这些代码也可以被视为符合规范。</i>
</p>
<p>
当在规范级别达成共识，关于最佳使用的编码值时，首选绑定将被使用，但也认识到由于各种原因，某些实施环境无法使用推荐的代码。应用程序应尽可能采用首选值集，因为这些首选值集最有可能在未来实现互操作性。对于这些绑定：
</p>
<ul>
  <li><b>code</b>：不应使用首选绑定与代码数据类型，因为由于无法为未包含在绑定值集中的代码指定system.url，其含义是不可预测的</li>
  <li><b>Coding</b>：值应来自指定的值集，但也可以使用其他代码和/或文本代替</li>
  <li><b>CodeableConcept</b>：其中一个Coding值应来自指定的值集，但也可以使用其他代码和/或文本代替</li>
</ul>
<p>
有关首选绑定的示例，请参见<a href="terminologies-binding-examples.html#preferred">术语绑定示例</a>。
</p>

<p>
当元素绑定到首选值集时，<a href="profiling.html">派生配置文件</a>可以将元素绑定到任何值集。
</p>

<a name="example"></a>
<h4>示例绑定强度</h4>
<p>
<i>不期望或鼓励实例使用指定的值集。该值集仅提供了所需包含的概念类型的示例。</i>
</p>
<p>
当元素具有非常广泛的含义（例如<a href="list.html">List</a>.code）或者对于正确使用的代码没有共识时，将使用示例绑定。对于这些绑定：
</p>
<ul>
 <li><b>code</b>：不应使用示例绑定与代码数据类型，因为由于无法为未包含在绑定值集中的代码指定system.url，其含义是不可预测的</li>
 <li><b>Coding</b>：系统/代码值可以是值集中的代码之一。</li>
 <li><b>CodeableConcept</b>：其中一个coding元素可以包含值集中的系统/代码。</li>
</ul>
<p>
可以使用其他某些编码值，或者（对于CodeableConcept）可以提供文本替代。示例值集用于帮助实施者理解元素的正确使用。基于具有限制性许可条款的代码系统（如SNOMED CT）的值集仅在基本FHIR规范中用作示例绑定，尽管特定司法管辖区的实施指南可能采用要求许可的值集。此外，还可以在基本规范中使用基于领域的明确定义的值集作为示例绑定。
</p>
<p>
有关示例绑定的示例，请参见<a href="terminologies-binding-examples.html#example">术语绑定示例</a>。
</p>

<p>
当元素绑定到示例值集时，<a href="profiling.html">派生配置文件</a>可以将元素绑定到任何值集。
</p>

<a name="expectations"></a>
<h4>绑定强度和一致性期望</h4>
<p>
“required”或“extensible”的绑定强度并不表示所有绑定值集中的代码都将被支持。它限制了允许共享的代码集。如果系统将一个元素标记为<a href="obligations.html">mustSupport</a>，则应使用<a href="[%extensions-location%]StructureDefinition-elementdefinition-minValueSet.html">minimumValueSet扩展</a>来标识必须由实施者支持的特定子集（可能是全部集合）的绑定代码。
</p>
<p>
如果未指定MIN值集，则对于实施者来说没有关于必须支持哪些代码的指导。然而，至少必须支持其中的一个代码。
</p>

<a name="max"></a>
<h3>最大值集</h3>
<p>
当将一个值集绑定到一个元素时，可以通过在<a href="terminologies.html#binding">附加绑定</a>中声明一个最大值集来限制值的范围。
</p>
<p>
可以进一步约束绑定，以声明一个值集，用于在绑定强度为“可扩展”或“首选”时使用。这个值集是可以从中获取额外代码的值集。这定义了对“可扩展”绑定的“必需”绑定的覆盖。
</p>

<a name="legacy"></a>
<h2>绑定和遗留数据</h2>
<p>
使用遗留或外部数据构建的系统，如果没有意识到绑定中所断言的术语要求，可能会难以满足绑定的期望。无论是“必需”还是“可扩展”的绑定，都对系统进行了映射其现有数据到值集的期望。对于“必需”绑定，如果无法进行映射，则无法发送该元素（即使使用扩展也不行）。如果该元素及其祖先元素的“min”基数都为1或更多，则系统无法生成符合规范的实例。对于可扩展绑定，如果已尝试映射但没有相应的概念，则可以自由发送遗留数据。然而，这仍然对执行映射的期望进行了施加，如果定期接收具有任意代码的新外部数据，则可能无法进行映射。如果没有执行映射，则需要省略该元素，或者实例将无法声称符合施加绑定的规范。
</p>
<p>
R5通过<a href="elementdefinition-definitions.html#ElementDefinition.binding.additional">附加绑定</a>扩展引入了一些新的绑定能力。该扩展允许规范指定更精细的绑定类型。特别是，“当前”绑定允许规范区分适用于系统从符合规范的时间开始捕获的数据与历史或外部数据的术语要求。如果实施者发现规范断言的绑定对于外部或历史数据来说过于繁重，但对于“当前”数据来说是合理的，可能会鼓励规范作者考虑使用此附加绑定扩展来更好地反映系统的期望。
</p>
<p>
服务器可以支持各种实施指南。不能保证它们在其FHIR接口上可用的所有数据都符合所有实施指南。另一方面，某些客户端可能无法安全地使用不符合给定IG的数据。在需要公开符合IG和非符合IG的数据混合的环境中，但某些消费者依赖于符合IG的数据以安全地使用时，可以使用Resource.meta.profile来显式标记符合规范的实例。然后，客户端可以使用_profile搜索参数进行过滤，以确保它们只接收到可以安全处理的数据 - 已知的代价是它们不一定能够访问到所有存在的数据。
</p>

<a name="other"></a>
<h2>其他注意事项</h2>

<ul>
 <li>如果在相关领域出现足够的共识，FHIR的后续版本可能会用首选绑定替换示例值集。</li>
 <li>作为规范的一部分提供的值集绑定始终特定于规范发布的值集版本。该值集可以通过定义一个简单的枚举代码列表来封闭，也可以通过其属性包括代码，并附带对底层代码系统的非版本特定引用，此时有效概念的列表可能会随时间变化。</li>
<li><a href="[%extensions-location%]StructureDefinition-elementdefinition-minValueSet.html">扩展 minValueSet</a> 可用于定义符合性所需的最小值集。</li>
</ul>
<!--
  <a name="strings"></a>
<h3>Binding String Values</h3>
<p>
In a few special cases, humans customarily use codes directly for elements that have type "string". A typical case is codes for states,
and there are several places where a URI must come from a set of controlled values.
An element of type <a href="datatypes.html#string">string</a> or <a href="datatypes.html#uri">uri</a> can also be bound to a value set.
When a string or URI is bound to a value set, the value property SHALL contain the code specified by the value set, and the system
and display values are ignored.
</p>
-->
<a name="Terminology-Service"></a>
<h3>术语服务</h3>
<p>
FHIR定义了一个<a href="terminology-service.html">术语服务</a>规范，该规范为支持代码、值集和代码系统的使用的系统设置了要求。
</p>
[%file newfooter%]

</body>
</html>

